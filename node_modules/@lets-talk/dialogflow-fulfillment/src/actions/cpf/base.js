const { CPFService } = require('./../../services/cpf_service');
const { AdaptorexService } = require("./../../services/adaptorex_service");
const constants = require('./../../constants');
const helpers = require('./helpers');
const context_helpers = require("./../../helpers/contexts");
const action_helpers = require('./actions');
const tdependence = require('./../../helpers/time_dependence');
const integrations = require('./../../helpers/integrations/base');
const loggerHelper = require("./../../helpers/logger");

const logger = loggerHelper.getLogger("FulfillmentActions");

async function closeConversation(params) {
  logger.info("Handling closeConversationAction with params", params);
  paramsUpdated = tdependence.evaluateTimeDependenceParams(params);
  await CPFService.addMultipleMessages(params, params.messages);
  await helpers.addMetadata(params);
  await helpers.addProjects(paramsUpdated);
  await helpers.addTags(paramsUpdated);
  await CPFService.close(params);
}


async function tagConversation(params) {
  logger.info("Handling tagConversationAction with params", params);
    await helpers.addProjects(params);
    await helpers.addTags(params);
}

async function transferConversation(params) {
  logger.info("Handling transferConversationAction with params", params);
  const currentDate = new Date();
  const inOfficeHour = helpers.isInOfficeHour(currentDate, params);
  const isAlreadyTransfered = context_helpers.doesContextExist(params, constants.contextNameBotHasTransfered);
  if (!inOfficeHour) {
    logger.info("Not in office hour. Reject transfer!");
    return await action_helpers.rejectTransferAction(params);
  }
  if (isAlreadyTransfered) {
    logger.info("Already transfered. Ignore transfer!");
    return
  }
  logger.info("transfer accepted");
  await action_helpers.acceptTransferAction(params)
}


function getErrorCatchers() {
  let errorCatchers = {}
  errorCatchers[constants.providers.twilio] = AdaptorexService.addMessage;
  errorCatchers[constants.providers.lt] = CPFService.addMessage;
  return errorCatchers;
}


async function executeCustomIntegration(params) {
  logger.info("Handling customIntegrationAction with params", params);
  const errorCatchers = getErrorCatchers();
  try {
    const data = await integrations.getIntegrationData(params);
    await integrations.applyIntegrationLogic(params, data);
  } catch (error) {
    logger.error("Error when executing custom integration", error);
    if(Object.keys(errorCatchers).includes(params.provider)) {
      await errorCatchers[params.provider](params, params.messages.error);
    }
    else {
      logger.error("Could not send error message to enduser.", {provider: params.provider});
    }
  }
}

exports.transferConversation = transferConversation;
exports.closeConversation = closeConversation;
exports.tagConversation = tagConversation;
exports.executeCustomIntegration = executeCustomIntegration;
