const uuid = require('uuid');

const constants = require('../../constants');
const helpers = require('../../actions/cpf/helpers');
const actions = require('../../actions/common');
const { CPFService } = require('../../services/cpf_service');
const df_service = require("./../../services/dialogflow");
const { AdaptorexService } = require('../../services/adaptorex_service');
const loggerHelper = require("./../logger");
const moment = require('moment-timezone');
const http_helper = require("./../../services/helper");
const context_helper = require("./../../helpers/contexts");

const logger = loggerHelper.getLogger("FulfillmentPaymentCodeNormaliza");

const contextPaymentCodeName = "paymentcodes";
const contextPaymentCodeLifespan = 50;

async function applyLogic(params, data) {
  const allCodes = Array.from(data)
  const validCodes = getValidPaymentCodes(params, allCodes);
  const cuotaDiaCodes = getCuotaDiaPaymentCodes(params, allCodes);
  if (validCodes.length === 1) {
    await handleValidCode(params, validCodes[0]);
  }
  else if(cuotaDiaCodes.length >= 1 && validCodes.length === 0) {
    await handleNoDebtCase(params);
  }
  else {
    await actions.transfer(params);
  }
};

function getValidPaymentCodes(params, codes) {
  return codes.filter(
    (code) => isValidPaymentCode(code, params)
  );
}

function getCuotaDiaPaymentCodes(params, codes) {
  return codes.filter(
    (code) => {return isCuotaDia(code, params)}
  );
}


async function handleValidCode(params, validCode) {
  const message = constructPaymentCodeSuccessMessage(params, validCode);
  try {
    await AdaptorexService.addMessage(params, message)
  } catch (error) {
    const errMsg = "Could not send payment code message to end user";
    logger.error(errMsg, { error: error });
    throw new Error(errMsg);
  }
  const outcomes = await Promise.allSettled([
      df_service.setContext(params, constants.contextNewTopic),
      tagConversationInCPF(params),
      savePaymentCodeMetadata(params, validCode),
  ]);
  const rejects = outcomes.filter(
    (elem) => {return elem.status === "rejected"}
  )
  if (rejects.length > 0) {
    logger.error("Could not fully complete payment code logic", {rejects: rejects});
  }
}

async function handleNoDebtCase(params) {
  await AdaptorexService.addMessage(params, params.integration.noDebtMessage);
  await df_service.setContext(params, constants.contextNewTopic);
}

async function tagConversationInCPF(params) {
  if (params.provider === constants.providers.lt) {
    await helpers.addTags({...params, ...{tag_list: params.integration.tag_list} });
  }
}

async function savePaymentCodeMetadata(params, validCode) {
  const requestedCodes = addPaymentCodeToBotContext(params, validCode);
    switch (params.provider) {
      case constants.providers.lt:
        await CPFService.addMetadata(params, { paymentcodes: requestedCodes });
        break;

      case constants.providers.twilio:
        await sendPaymentCodesToDataRescuer(params, validCode);
        break;

      default:
        throw new Error("No such Provider exists. Please define new method to persist payment codes");
    }
}

async function sendPaymentCodesToDataRescuer(params, validCode) {
  const requestOptions = {
    url: params.integration.url_publish_codes_whatsapp,
    payload: {
      body: {
        payload: {
          metadata: {
            payment_code: `${validCode.ordenCodigo}`,
          },
          topic: params.topic,
          provider: params.provider,
          reference: params.session,
          event_time: new Date().toISOString(),
          event_id: uuid.v4(),
        },
      },
      method: "POST",
    },
  };
  await http_helper.sendRequest(requestOptions);
}

function isValidPaymentCode(paymentCode, params) {
  const allowedStatuses = params.integration.allowedStatuses;
  const excludedCampaigns = params.integration.excludedCampaigns;
  const isNotExcludedCampaign = ! excludedCampaigns.includes(paymentCode.campanna);
  const hasValidStatus = allowedStatuses.includes(paymentCode.ordenEstadoNombre);
  return hasValidStatus && isNotExcludedCampaign && hasAllowedDate(paymentCode, params);
};

function isCuotaDia(paymentCode, params) {
  return paymentCode.campanna === "CUOTA_DIA" && hasAllowedDate(paymentCode, params);
};

function hasAllowedDate(paymentCode, params) {
  const curDate = moment().tz(params.availability.timezone).format("YYYY-MM-DD");
  return paymentCode.fechaLimite >= curDate;
}

function constructPaymentCodeSuccessMessage(params, paymentCode) {
  var message = params.integration.successMessage
  message = message.replace("param.permalink", paymentCode.permalink);
  message = message.replace("param.ordenTotal", paymentCode.ordenTotal);
  message = message.replace("param.ordenCodigo", paymentCode.ordenCodigo);
  message = message.replace("param.fechaLimite", paymentCode.fechaLimite);
  return message;
};

function addPaymentCodeToBotContext(params, validCode) {
  const curCodes = getPreviousPaymentCodes(params);
  curCodes.push(validCode.ordenCodigo)
  let codeStr = curCodes.join(",");
  if (codeStr.startsWith(",")) {
    codeStr = codeStr.substr(1);
  }
  const ctx = {
    "name": contextPaymentCodeName,
    "lifespan": contextPaymentCodeLifespan,
    "parameters": {
      "paymentcodes": codeStr,
    }
  };
  logger.info("Current payment code context", ctx);
  df_service.setContext(params, ctx);
  return codeStr;
};

function getPreviousPaymentCodes(params) {
  const ctx = context_helper.getContextsWithName(params, contextPaymentCodeName);
  logger.info("Current paymentcode context", ctx);
  if (ctx.length >= 1) {
    return ctx[0].parameters.paymentcodes.split(",");
  } else {
    return [];
  }
};

exports.applyLogic = applyLogic;
exports.hasAllowedDate = hasAllowedDate;
