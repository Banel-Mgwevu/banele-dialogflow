const actions = require("./../../../src/actions/adaptorex/actions");
const tdep = require("./../../../src/helpers/time_dependence");
const helpers = require("./../../../src/actions/cpf/helpers");
const constants = require("./../../../src/constants");
let { AdaptorexService } = require("./../../../src/services/adaptorex_service");
let df_service = require("./../../../src/services/dialogflow");

const mockAddMember = jest.fn();
const mockDeleteMember = jest.fn();
const mockDeleteChat = jest.fn();
const mockAddMessages = jest.fn();
const mockAddSystemMessages = jest.fn();
AdaptorexService.addMember = mockAddMember;
AdaptorexService.deleteMember = mockDeleteMember;
AdaptorexService.deleteChat = mockDeleteChat;
AdaptorexService.addMessages = mockAddMessages;
AdaptorexService.addSystemMessages = mockAddSystemMessages;

const mInOfficeHour = jest.spyOn(helpers, "isInOfficeHour");
const mEvalTDep = jest.spyOn(tdep, "evaluateTimeDependenceParams");
const mSetContext = jest.spyOn(df_service, "setContext").mockImplementation();

describe("transferTwilio2LT", () => {
    const params = {
        messages: {
            accept: ["OK!"],
            reject: ["Not available"],
        }
    }
    beforeEach(() => {
        mInOfficeHour.mockClear();
        mEvalTDep.mockClear();
        mSetContext.mockClear();
    });

    describe("when in office hour", () => {
        beforeEach(() => {
            mInOfficeHour.mockImplementationOnce(
                () => { return true }
            );
        });

        it("adds the expected message to the agent", async () => {
            expect.assertions(1);
            await actions.transferTwilio2LT(params);
            expect(AdaptorexService.addSystemMessages).toHaveBeenCalledWith(params, params.messages.accept);
        });

        it("adds a member to the conversation", async () => {
            expect.assertions(1);
            await actions.transferTwilio2LT(params);
            expect(AdaptorexService.addMember).toHaveBeenCalledWith(params);
        });

        it("deletes a member from the conversation", async () => {
            expect.assertions(1);
            await actions.transferTwilio2LT(params);
            expect(AdaptorexService.deleteMember).toHaveBeenCalledWith(params);
        });

        it("evaluated time dependence of parameters", async () => {
            expect.assertions(1);
            await actions.transferTwilio2LT(params);
            expect(mEvalTDep).toHaveBeenCalledWith(params);
        });

    });

    describe("when out of office hour", () => {
        beforeEach(() => {
            mInOfficeHour.mockImplementationOnce(
                () => { return false }
            );
        });

        it("adds the expected message to the agent", async () => {
            expect.assertions(1);
            await actions.transferTwilio2LT(params);
            expect(mockAddMessages).toHaveBeenCalledWith(params, params.messages.reject);
        });

        it("sets the context of the agent", async () => {
            expect.assertions(1);
            await actions.transferTwilio2LT(params);
            expect(mSetContext).toHaveBeenCalledWith(params, constants.contextNewTopic);
        });

        it("evaluated time dependence of parameters", async () => {
            expect.assertions(1);
            await actions.transferTwilio2LT(params);
            expect(mEvalTDep).toHaveBeenCalledWith(params);
        });
    });

    describe("when out of office hour and should not set newTopic context", () => {
        const newParams = {
            ...params,
            ...{doNotSetNewTopicContext: true}
        };

        beforeEach(() => {
            mInOfficeHour.mockImplementationOnce(
                () => { return false }
            );
        });

        it("adds the expected message to the agent", async () => {
            expect.assertions(1);
            await actions.transferTwilio2LT(newParams);
            expect(mockAddMessages).toHaveBeenCalledWith(newParams, newParams.messages.reject);
        });

        it("does not set the context of the agent", async () => {
            expect.assertions(1);
            await actions.transferTwilio2LT(newParams);
            expect(mSetContext).not.toHaveBeenCalled();
        });

        it("evaluated time dependence of parameters", async () => {
            expect.assertions(1);
            await actions.transferTwilio2LT(newParams);
            expect(mEvalTDep).toHaveBeenCalledWith(newParams);
        });
    });
});

describe("closeConversationTwilio", () => {
    const params = {
        messages: ["Gracias y ciao!"]
    };

    it("adds the expected message to the agent", async () => {
        expect.assertions(1);
        await actions.closeConversationTwilio(params);
        expect(AdaptorexService.addMessages).toHaveBeenCalledWith(params, params.messages);
    });
    it("deletes the chat using ARex API", async () => {
        expect.assertions(1);
        await actions.closeConversationTwilio(params);
        expect(AdaptorexService.deleteChat).toHaveBeenCalledWith(params);
    });
});