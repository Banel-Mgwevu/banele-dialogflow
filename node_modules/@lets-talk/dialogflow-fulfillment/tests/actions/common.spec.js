const actions = require("./../../src/actions/common");
const actionsArex = require("./../../src/actions/adaptorex/actions");
const actionsCPF = require("./../../src/actions/cpf/base");
const constants = require("./../../src/constants");
const http_helper = require("./../../src/services/helper");
let { AdaptorexService } = require("./../../src/services/adaptorex_service");
let { CPFService } = require("./../../src/services/cpf_service");

const mSendRequest = jest.spyOn(http_helper, "sendRequest").mockImplementation();

const mTransferCPF = jest.spyOn(actionsCPF, "transferConversation").mockImplementation();
const mTransferAex = jest.spyOn(actionsArex, "transferTwilio2LT").mockImplementation();

const mCloseCPF = jest.spyOn(actionsCPF, "closeConversation").mockImplementation();
const mCloseAex = jest.spyOn(actionsArex, "closeConversationTwilio").mockImplementation();

const mAddMsgsCPF = jest.fn();
const mAddMsgsAex = jest.fn();

AdaptorexService.addMessage = mAddMsgsAex;
CPFService.addMultipleMessages = mAddMsgsCPF;

const mockLoggerError = jest.fn();
const mockLoggerInfo = jest.fn();

jest.mock("./../../src/helpers/logger", () => {
  return {
    getLogger: jest.fn(() => ({
      info: jest.fn((...args) => mockLoggerInfo(...args)),
      error: jest.fn((...args) => mockLoggerError(...args)),
    })),
  };
});

describe("transfer", () => {
    beforeEach(() => {
        mTransferAex.mockClear();
        mTransferCPF.mockClear();
    })

    describe("when provider is twilio", () => {
        const params = {
            provider: constants.providers.twilio
        }
        it("calls twilio transfer", async () => {
            expect.assertions(1);
            await actions.transfer(params);
            expect(mTransferAex).toHaveBeenCalledWith(params);
        });
    });

    describe("when provider is undefined", () => {
        const params = {
            provider: undefined
        }
        it("calls CPF transfer", async () => {
            expect.assertions(1);
            await actions.transfer(params);
            expect(mTransferCPF).toHaveBeenCalledWith(params);
        });
    });
}),

describe("close", () => {
    beforeEach(() => {
        mCloseAex.mockClear();
        mCloseCPF.mockClear();
    })

    describe("when provider is twilio", () => {
        const params = {
            provider: constants.providers.twilio
        }
        it("calls twilio transfer", async () => {
            expect.assertions(1);
            await actions.close(params);
            expect(mCloseAex).toHaveBeenCalledWith(params);
        });
    });

    describe("when provider is undefined", () => {
        const params = {
            provider: undefined
        }
        it("calls CPF transfer", async () => {
            expect.assertions(1);
            await actions.close(params);
            expect(mCloseCPF).toHaveBeenCalledWith(params);
        });
    });
});

describe("delegate request", () => {
    const request = {
        body: {
            key: "value"
        },
        headers: {
            "X-Forwarded-Proto": "https",
            Host: "host/",
        },
        requestContext: {
            path: "path",
        },
        queryStringParameters: {
            p1: "val1",
        }
    };
    beforeEach(() => {
        mSendRequest.mockClear();
    })

    const expectedRequestOptions = {
        url: "https://host/path?p1=val1",
        payload: {
            body: {
                key: "value",
                hasDelegated: true,
            },
            method: "POST",
        }
    }
    it("sends request with expected options", async () => {
        expect.assertions(1);
        await actions.delegateRequest(request);
        expect(mSendRequest).toHaveBeenCalledWith(expectedRequestOptions);
    });
})

describe("add Messages", () => {
    const msgs = ["Hola. CÃ³mo estamos?"];
    beforeEach(() => {
        mAddMsgsAex.mockClear();
        mAddMsgsCPF.mockClear();
        mockLoggerError.mockClear();
    })

    describe("when provider is twilio", () => {
        const params = {
            provider: constants.providers.twilio
        }
        it("adds messages using adaptorex", async () => {
            expect.assertions(1);
            await actions.addMessages(params, msgs);
            expect(mAddMsgsAex).toHaveBeenCalledWith(params, msgs[0]);
        });
    });

    describe("when provider is lt", () => {
        const params = {
            provider: constants.providers.lt
        }
        it("adds messages using camperfarm service", async () => {
            expect.assertions(1);
            await actions.addMessages(params, msgs);
            expect(mAddMsgsCPF).toHaveBeenCalledWith(params, msgs);
        });
    });

    describe("when provider is unknown", () => {
        const params = {
            provider: "other"
        }
        it("logs an error", async () => {
            expect.assertions(1);
            try {
                await actions.addMessages(params, msgs);
            } catch (error) {}
            expect(mockLoggerError).toHaveBeenCalledWith(
                constants.errorMessages.unknownProvider,
                { provider: "other" }
            );
        });

        it("throws an error", async () => {
            await expect(actions.addMessages(params, msgs))
            .rejects
            .toThrow(constants.errorMessages.unknownProvider)
        })
    });
})