const { advanceTo, clear } = require('jest-date-mock');

const actions = require('../../../src/actions/cpf/base');
const helpers = require('../../../src/actions/cpf/helpers');
const action_helpers = require('../../../src/actions/cpf/actions');
const tdependence = require('../../../src/helpers/time_dependence');
const integrations = require('../../../src/helpers/integrations/base');
const constants = require("./../../../src/constants");
let { CPFService } = require('../../../src/services/cpf_service');
const df_agent = require('../../../src/services/dialogflow');

tagConversation = actions.tagConversation;
closeConversation = actions.closeConversation;
transferConversation = actions.transferConversation;
customIntegration = actions.executeCustomIntegration;

jest.useFakeTimers();

const mockedAgent = {
  add: jest.fn(),
  setContext: jest.fn(),
  getContext: jest.fn(),
};

const mockCPFService_AddMetadata = jest.fn();
const mockCPFService_AddTags = jest.fn();
const mockCPFService_AddProjects = jest.fn();
const mockCPFService_Close = jest.fn();
const mockCPFService_AddMultipleMsgs = jest.fn();
const mockCPFService_AddMessage = jest.fn();
const mockCPFService_Transfer = jest.fn();

CPFService.close = mockCPFService_Close;
CPFService.addMetadata = mockCPFService_AddMetadata;
CPFService.addTags = mockCPFService_AddTags;
CPFService.addProjects = mockCPFService_AddProjects;
CPFService.addMultipleMessages = mockCPFService_AddMultipleMsgs;
CPFService.addMessage = mockCPFService_AddMessage;
CPFService.transfer = mockCPFService_Transfer;

const mockDoesContextExist = jest.spyOn(df_agent, "doesContextExist").mockImplementation();

describe('actions', () => {
  const addMetadata = jest.spyOn(helpers, 'addMetadata');
  const addProject = jest.spyOn(helpers, 'addProjects');
  const addTags = jest.spyOn(helpers, 'addTags');
  const rejectTransfer = jest.spyOn(action_helpers, 'rejectTransferAction');
  const acceptTransfer = jest.spyOn(action_helpers, 'acceptTransferAction');
  const evalTimeDependence = jest.spyOn(tdependence, 'evaluateTimeDependenceParams');

  beforeEach(() => {
    clear();
    rejectTransfer.mockClear();
    acceptTransfer.mockClear();

    addMetadata.mockImplementationOnce();
    addProject.mockImplementationOnce();
    addTags.mockImplementationOnce();

    addMetadata.mockClear();
    addTags.mockClear();
    addProject.mockClear();
    evalTimeDependence.mockClear();

    mockCPFService_Close.mockClear();
    mockCPFService_AddMessage.mockClear();
    mockCPFService_Transfer.mockClear();
    mockCPFService_AddMultipleMsgs.mockClear();
    mockedAgent.add.mockClear();
    mockedAgent.setContext.mockClear();
    mockedAgent.getContext.mockClear();
  });

  describe('tagConversation', () => {

    const params = {
      project_list: ["SPR-PERS"]
    }

    it('calls addProject', async () => {
      expect.assertions(1);
      await tagConversation(params);
      expect(addProject).toBeCalledTimes(1);
    });

    it('calls addProject with correct params', async () => {
      expect.assertions(1);
      await tagConversation(params);
      expect(addProject).toBeCalledWith(params);
    });

    it('calls addTags', async () => {
      expect.assertions(1);
      await tagConversation(params);
      expect(addTags).toBeCalledTimes(1);
    });

    it('calls addTags with correct params', async () => {
      expect.assertions(1);
      await tagConversation(params);
      expect(addTags).toBeCalledWith(params);
    });
  })

  describe('closeConversation', () => {
    const params = {
      messages: [
        "Hola, gracias por contactarnos."
      ],
      other: "value"
    }

      it('evaluates time dependence of the parameters', async () => {
        expect.assertions(1);
        await closeConversation(params);
        expect(evalTimeDependence).toBeCalledWith(params);
      });

    it('calls CPFService to add messages to the conversation', async () => {
      expect.assertions(1);
      await closeConversation(params);
      expect(mockCPFService_AddMultipleMsgs).toBeCalledWith(params, params.messages)
    });

    it('calls to CPFService to close the conversation', async () => {
      expect.assertions(1);
      await closeConversation(params);
      expect(mockCPFService_Close).toBeCalledTimes(1);
    });

    it('calls to CPFService to close the conversation with correct params', async () => {
      expect.assertions(1);
      await closeConversation(params);
      expect(mockCPFService_Close).toBeCalledWith(params);
    });

    it('calls to maybe add metadata', async () => {
      expect.assertions(1);
      await closeConversation(params);
      expect(addMetadata).toBeCalledTimes(1);
    });

    it('calls maybe add metadata with the correct params', async () => {
      expect.assertions(1);
      await closeConversation(params);
      expect(addMetadata).toBeCalledWith(params);
    });

    it('calls to add tags with the correct params', async () => {
      expect.assertions(1);
      await closeConversation(params);
      expect(addTags).toBeCalledWith(params);
    });

    it('calls to add projects with the correct params', async () => {
      expect.assertions(1);
      await closeConversation(params);
      expect(addProject).toBeCalledWith(params);
    });
  });

  describe('transferConversation', () => {
    beforeEach(() => {
      rejectTransfer.mockImplementationOnce(() => void(0));
      acceptTransfer.mockImplementationOnce(() => void(0));
    });

    describe('when in office hour', () => {
      beforeEach(() => {
        jest.spyOn(helpers, 'isInOfficeHour').mockImplementationOnce(() => { return true });
      });
      describe('when bot already transfered', () => {
          const params = {
            messages: [
              "Hola, gracias por contactarnos."
            ],
            other: "value",
            contexts: [{
              name: constants.contextNameBotHasTransfered
            }]};
        it('does not call the reject transfer action', async () => {
          await transferConversation(params);
          expect(rejectTransfer).not.toBeCalled();
        });

        it('does not call the accept transfer', async () => {
          await transferConversation(params);
          expect(acceptTransfer).not.toBeCalled();
        });
      });

      describe('when bot has not yet transfered', () => {

        const params = {
          messages: [
            "Hola, gracias por contactarnos."
          ],
          other: "value",
          contexts: []
        };

        it('accepts the transfer', async () => {
          await transferConversation(params);
          expect(acceptTransfer).toBeCalledTimes(1);
        });

        it('accepts the transfer with correct params', async () => {
          await transferConversation(params);
          expect(acceptTransfer).toBeCalledWith(params);
        });

        it('does not call the reject transfer', async () => {
          await transferConversation(params);
          expect(rejectTransfer).not.toBeCalled();
        });
      });
    });

    describe('when out of office hour', () => {
      beforeEach(() => {
        jest.spyOn(helpers, 'isInOfficeHour').mockImplementationOnce(() => { return false });
      });

      it('rejects the transfer when not yet transfered', async () => {
        const params = { contexts: [] };
        await transferConversation(params);
        expect(rejectTransfer).toBeCalledTimes(1);
      });

      it('rejects the transfer when already transfered', async () => {
        const params = { contexts: [{name: constants.contextNameBotHasTransfered}] };
        await transferConversation(params);
        expect(rejectTransfer).toBeCalledTimes(1);
      });
    });
  });

  describe("executeCustomIntegration", () => {
    mGetIntegrationData = jest.spyOn(integrations, "getIntegrationData");
    mApplyIntegrationLogic = jest.spyOn(integrations, "applyIntegrationLogic");
    const params = {
      provider: constants.providers.lt,
      messages: {
        error: "Something went wrong",
      }
    }
    const data = jest.fn();

    describe("success case", () => {
      beforeEach(() => {
        mGetIntegrationData.mockClear();
        mApplyIntegrationLogic.mockClear();

        mGetIntegrationData.mockImplementationOnce(() => {
          return new Promise((res) => {res(data)});
        });
        mApplyIntegrationLogic.mockImplementationOnce();
      })
      it("gets integration data", async () => {
        await customIntegration(params);
        expect(mGetIntegrationData).toHaveBeenCalledWith(params);
      });

      it("applies integration logic", async () => {
        await customIntegration(params);
        expect(mApplyIntegrationLogic).toHaveBeenCalledWith(params, data);
      });
    });

    describe("failure case", () => {
      beforeEach(() => {
        mGetIntegrationData.mockClear();
        mApplyIntegrationLogic.mockClear();

        mGetIntegrationData.mockImplementationOnce(() => {
          throw new Error("something went wrong");
        });
        mApplyIntegrationLogic.mockImplementationOnce(() => {
          return true;
        });
      })
      it("gets integration data", async () => {
        await customIntegration(params);
        expect(mGetIntegrationData).toHaveBeenCalledWith(params);
      });

      it("returns false", async () => {
        const result = await customIntegration(params);
        expect(result).toBeFalsy();
      });

      it("adds error message to conversation", async () => {
        await customIntegration(params);
        expect(mockCPFService_AddMessage).toHaveBeenCalledWith(params, "Something went wrong");
      });
    });
  });
});
