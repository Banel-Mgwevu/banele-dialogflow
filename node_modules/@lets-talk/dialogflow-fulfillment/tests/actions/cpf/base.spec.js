const { advanceTo, clear } = require('jest-date-mock');
const helpers = require('./../../../src/actions/cpf/helpers');
let { CPFService } = require('../../../src/services/cpf_service');

const mockCPFService_AddMetadata = jest.fn();
const mockCPFService_AddTags = jest.fn();
const mockCPFService_AddProjects = jest.fn();
const mockCPFService_Transfer = jest.fn();

CPFService.addMetadata = mockCPFService_AddMetadata;
CPFService.addTags = mockCPFService_AddTags;
CPFService.transfer = mockCPFService_Transfer;
CPFService.addProjects = mockCPFService_AddProjects;

describe('utcDateToString', () => {
  test('returns expected string format', () => {
    var date = new Date('October 17, 2018 07:55:00');
    date.setUTCHours(7);  //needed to avoid timezone madness in tests
    expect(helpers.utcDateToString(date)).toEqual('2018-10-17T07:55:00z')
  });
});


describe('currentUtcDateInString', () => {
  beforeEach(() => {
    advanceTo(new Date('October 17, 2018 07:55:00'));
  });

  afterEach(() => {
    // This reset the mockDate
    clear();
  });

  test('returns current time in expected format', () => {
    const now = Date.now();
    const expectedDate = new Date(now);

    const expectedDateString = helpers.utcDateToString(expectedDate);
    expect(helpers.currentUtcDateInString()).toEqual(expectedDateString)
  });
});


describe('maybe helpers', () => {
  beforeEach(() => {
    mockCPFService_AddMetadata.mockClear();
    mockCPFService_AddTags.mockClear();
    mockCPFService_AddProjects.mockClear();
  });

  describe('addTags', () => {
    describe('When there is a tag_list', () => {
      const params = {
        tag_list: ['CC-PAGO', 'LOGIN'],
      }

      it('Calls CPFService.addTags', async () => {
        expect.assertions(1);
        await helpers.addTags(params);
        expect(mockCPFService_AddTags).toHaveBeenCalledTimes(1);
      });

      it('Calls CPFService.addTags with the correct params', async () => {
        expect.assertions(1);
        await helpers.addTags(params);
        expect(mockCPFService_AddTags).toHaveBeenCalledWith(params);
      });
    });

    describe('When there is NO tag_list', () => {
      const params = {}
      it('Does not calls CPFService.addTags', async () => {
        expect.assertions(1);
        await helpers.addTags(params);
        expect(mockCPFService_AddTags).not.toHaveBeenCalled();
      });
    });
  });

  describe('addProjects', () => {
    describe('When there is a project_list', () => {
      const params = {
        project_list: ["SPR-PERS"],
        otro_param: 'otro_value'
      };

      it('calls the CPF service to add the project', async () => {
        expect.assertions(1);
        await helpers.addProjects(params);
        expect(mockCPFService_AddProjects).toHaveBeenCalledTimes(1);
      });

      it('calls the CPF service with the all params', async () => {
        expect.assertions(1);
        await helpers.addProjects(params);
        expect(mockCPFService_AddProjects).toHaveBeenCalledWith(params);
      });

    });

    describe('When there is NO project_list', () => {
      const params = { otro: "param" };

      it('does not call the CPF service', async () => {
        expect.assertions(1);
        await helpers.addProjects(params);
        expect(mockCPFService_AddProjects).not.toHaveBeenCalled();
      });

    });
  });

  describe('addMetadata', () => {
    describe('When there is metadata', () => {
      const params = {
        metadata: {
          bot_name: "bkn"
        },
        otro_param: "otro value"
      };

      it('calls the CPF service to add the metadata', async () => {
        expect.assertions(1);
        await helpers.addMetadata(params);
        expect(mockCPFService_AddMetadata).toHaveBeenCalledTimes(1);
      });

      it('calls the CPF service with all params', async () => {
        expect.assertions(1);
        await helpers.addMetadata(params);
        expect(mockCPFService_AddMetadata).toHaveBeenCalledWith(params, { bot_name: "bkn" });
      });
    });

    describe('When there is NO metadata', () => {
      const params = { otro_param: "otro value" };

      it('does not call the CPF service', async () => {
        expect.assertions(1);
        await helpers.addMetadata(params);
        expect(mockCPFService_AddMetadata).not.toHaveBeenCalled();
      });
    });

    describe('When there are dynamic metadata parameters', () => {
      const params = {
        extra: {
          dyn_param: "val_1",
          otro_param: "otro_val"
        },
        display_details: {
          dynamic: ["dyn_param"],
      },
    };

      it('adds the metadata to CPF', async () => {
        expect.assertions(1);
        await helpers.addMetadata(params);
        expect(mockCPFService_AddMetadata).toHaveBeenCalledWith(params, {dyn_param: "val_1"});
      });
    });

    describe('When there are no dynamic metadata parameters', () => {
      const params = {
        extra: {
          otro_param: "otro_val"
        },
        display_details: {
          dynamic: ["dyn_param"],
      },
    };

      it('does not add metadata to CPF', async () => {
        expect.assertions(1);
        await helpers.addMetadata(params);
        expect(mockCPFService_AddMetadata).not.toHaveBeenCalled();
      });
    });

    describe('When there is time-dependent metadata', () => {
      const params = {
        metadata: {
          date: "fct:utcDateInString"
        },
        otro_param: "otro value"
      };



      beforeEach(() => {
        advanceTo(new Date('June 17, 2020 15:01:00'));
      });

      afterEach(() => {
        // This reset the mockDate
        clear();
      });


      it('calls the CPF service to add the metadata', async () => {
        expect.assertions(1);
        await helpers.addMetadata(params);
        expect(mockCPFService_AddMetadata).toHaveBeenCalledTimes(1);
      });

      it('calls the CPF service with the expected params', async () => {
        expect.assertions(1);
        const expectedDateString = helpers.utcDateToString(new Date('June 17, 2020 15:01:00'));

        await helpers.addMetadata(params);
        const expected_metadata = {
          date: expectedDateString
        };
        expect(mockCPFService_AddMetadata).toHaveBeenCalledWith(params, expected_metadata);
      });
    });
  });
});


describe('isInOfficeHour', () => {
  const params = {
    availability: {
      opening_times: {
        mon: [
          '09:00',
          '17:50'
        ],
        tue: [
          '09:00',
          '17:50'
        ],
        wed: [
          '09:00',
          '17:50'
        ],
        thu: [
          '09:00',
          '17:50'
        ],
        fri: [
          '09:00',
          '17:50'
        ],
        sat: [],
        sun: [],
        "2020-01-01": [],
        "2020-12-25": []
      },
      timezone: "America/Santiago"
    },
  };

  describe('When normal week day', () => {
    describe('When in office hour', () => {

      afterEach(() => {
        // This reset the mockDate
        clear();
      });

    it('Should return true a second before closing', () => {
        advanceTo(new Date('June 18, 2020 17:49:59-04:00'));
        expect.assertions(1);
        const result = helpers.isInOfficeHour(new Date(), params);

        expect(result).toBeTruthy();
      });

    it('Should return true a second after opening', () => {
        advanceTo(new Date('June 18, 2020 09:00:01-04:00'));
        expect.assertions(1);
        const result = helpers.isInOfficeHour(new Date(), params);

        expect(result).toBeTruthy();
      });

      it('Should return true a second before closing when DST', () => {
        advanceTo(new Date('September 8, 2020 17:49:59-03:00'));
        expect.assertions(1);
        const result = helpers.isInOfficeHour(new Date(), params);

        expect(result).toBeTruthy();
      });

    it('Should return true a second after opening when DST', () => {
        advanceTo(new Date('September 8, 2020 09:00:01-03:00'));
        expect.assertions(1);
        const result = helpers.isInOfficeHour(new Date(), params);

        expect(result).toBeTruthy();
      });
    });

    describe('When in closed hour', () => {

      afterEach(() => {
        // This reset the mockDate
        clear();
      });

    it('Should return false a second after closing', () => {
        advanceTo(new Date('June 18, 2020 17:50:01-04:00'));
        expect.assertions(1);
        const result = helpers.isInOfficeHour(new Date(), params);
        expect(result).toBeFalsy();
      });

      it('Should return false a second before opening', () => {
        advanceTo(new Date('June 18, 2020 08:59:59-04:00'));
        expect.assertions(1);
        const result = helpers.isInOfficeHour(new Date(), params);
        expect(result).toBeFalsy();
      });
      it('Should return false a second after closing when DST', () => {
        advanceTo(new Date('September 8, 2020 17:50:01-03:00'));
        expect.assertions(1);
        const result = helpers.isInOfficeHour(new Date(), params);
        expect(result).toBeFalsy();
      });

      it('Should return false a second before opening when DST', () => {
        advanceTo(new Date('September 8, 2020 08:59:59-03:00'));
        expect.assertions(1);
        const result = helpers.isInOfficeHour(new Date(), params);
        expect(result).toBeFalsy();
      });
    });
  });

  describe('When weekend', () => {

    beforeEach(() => {
      advanceTo(new Date('June 21, 2020 15:00:00-04:00'));
    });

    afterEach(() => {
      // This reset the mockDate
      clear();
    });

    it('Should return false', () => {
      expect.assertions(1);
      const result = helpers.isInOfficeHour(new Date(), params);

      expect(result).toBeFalsy();
    });
  });

  describe('When special day', () => {

    beforeEach(() => {
      advanceTo(new Date('December 25, 2020 12:00:00-04:00'));
    });

    afterEach(() => {
      // This reset the mockDate
      clear();
    });

    it('Should return false', () => {
      expect.assertions(1);
      const result = helpers.isInOfficeHour(new Date(), params);

      expect(result).toBeFalsy();
    });
  });
});