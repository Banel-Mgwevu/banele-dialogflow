const action_helpers = require('./../../../src/actions/cpf/actions');
const constants = require('../../../src/constants');
const helpers = require('../../../src/actions/cpf/helpers');
const helpers_time = require('../../../src/helpers/time_dependence');
const df_service = require("./../../../src/services/dialogflow");
let { CPFService } = require('../../../src/services/cpf_service');

const mockCPFService_Transfer = jest.fn();
const mockCPFService_AddMultipleMsgs = jest.fn();
const mockCPFService_AddMessage = jest.fn();

CPFService.transfer = mockCPFService_Transfer;
CPFService.addMultipleMessages = mockCPFService_AddMultipleMsgs;
CPFService.addMessage = mockCPFService_AddMessage;

const mockLoggerError = jest.fn();
const mockLoggerInfo = jest.fn();

jest.mock("./../../../src/helpers/logger", () => {
  return {
    getLogger: jest.fn(() => ({
      info: jest.fn((...args) => mockLoggerInfo(...args)),
      error: jest.fn((...args) => mockLoggerError(...args)),
    })),
  };
});

const mSetContext = jest.spyOn(df_service, "setContext").mockImplementation();

describe('actionHelpers', () => {

  const params = {
    messages: {
      accept: [
        "OK, we will transfer.",
        "Someone will be talking to you soon."
      ],
      reject: ["We cannot transfer right now."],
      error: ["Something went wrong. Please try again"]
    }
  }

  beforeEach(() => {
    mockCPFService_AddMultipleMsgs.mockClear();
    mSetContext.mockClear();
  });

  describe('rejectTransferAction', () => {

    it("the agent sets a context", async () => {
      expect.assertions(1);
      await action_helpers.rejectTransferAction(params);
      expect(mSetContext).toBeCalledTimes(1);
    });

    it("the agent sets the correct context", async () => {
      expect.assertions(1);
      await action_helpers.rejectTransferAction(params);
      expect(mSetContext).toBeCalledWith(params, constants.contextNewTopic);
    });

    it("the agent sends the expected message", async () => {
      expect.assertions(1);
      await action_helpers.rejectTransferAction(params);
      expect(mockCPFService_AddMultipleMsgs).toBeCalledWith(params, params.messages.reject)
    });
  });

  describe('rejectTransferAction deactivating new context', () => {
    const params = {
      doNotSetNewTopicContext: true,
      messages: {
        accept: [
          "OK, we will transfer.",
          "Someone will be talking to you soon."
        ],
        reject: ["We cannot transfer right now."],
        error: ["Something went wrong. Please try again"]
      }
    }

    it("the agent does not set a context", async () => {
      expect.assertions(1);
      await action_helpers.rejectTransferAction(params);
      expect(mSetContext).toBeCalledTimes(0);
    });

    it("the agent sends the expected message", async () => {
      expect.assertions(1);
      await action_helpers.rejectTransferAction(params);
      expect(mockCPFService_AddMultipleMsgs).toBeCalledWith(params, params.messages.reject)
    });
  });


  describe('acceptTransferAction', () => {
    const maybeAddMetadata = jest.spyOn(helpers, 'addMetadata');
    const maybeAddProjects = jest.spyOn(helpers, 'addProjects');
    const maybeAddTags = jest.spyOn(helpers, 'addTags');
    const evaluateTimeDependence = jest.spyOn(helpers_time, 'evaluateTimeDependenceParams');

    beforeEach(() => {
      maybeAddMetadata.mockReset();
      maybeAddTags.mockReset();
      maybeAddProjects.mockReset();

      evaluateTimeDependence.mockClear();
      mockCPFService_Transfer.mockClear();
      mockCPFService_AddMultipleMsgs.mockClear();

      mSetContext.mockClear();

      maybeAddMetadata.mockImplementationOnce();
      maybeAddProjects.mockImplementationOnce();
      maybeAddTags.mockImplementationOnce();
    });
    describe("when all successful", () => {

      it('the agent sets a context', async () => {
        expect.assertions(1);
        await action_helpers.acceptTransferAction(params);
        expect(mSetContext).toBeCalledTimes(1);
      });

      it('agent sets the correct context', async () => {
        expect.assertions(1);
        await action_helpers.acceptTransferAction(params);
        expect(mSetContext).toBeCalledWith(params, constants.contextBotHasTransfered);
      });

      it('sends the messages via CPF API', async () => {
        expect.assertions(1);
        await action_helpers.acceptTransferAction(params);
        expect(mockCPFService_AddMultipleMsgs).toBeCalledTimes(1);
      })

      it('sends the expected messages via CPF API', async () => {
        expect.assertions(1);
        await action_helpers.acceptTransferAction(params);
        expect(mockCPFService_AddMultipleMsgs.mock.calls[0][1]).toEqual(params.messages.accept);
      })

      it('calls to maybeAddProjects', async () => {
        expect.assertions(1);
        await action_helpers.acceptTransferAction(params);
        expect(maybeAddProjects).toBeCalledTimes(1);
      });

        it('calls to maybeAddTag', async () => {
        expect.assertions(1);
        await action_helpers.acceptTransferAction(params);
        expect(maybeAddTags).toBeCalledTimes(1);
      });

        it('calls to maybeAddMetadata', async () => {
        expect.assertions(1);
        await action_helpers.acceptTransferAction(params);
        expect(maybeAddMetadata).toBeCalledTimes(1);
      });

        it('calls to maybeAddProjects with correct params', async () => {
        expect.assertions(1);
        await action_helpers.acceptTransferAction(params);
        expect(maybeAddProjects).toBeCalledWith(params);
      });

      it('calls to maybeAddTag with correct params', async () => {
        expect.assertions(1);
        await action_helpers.acceptTransferAction(params);
        expect(maybeAddTags).toBeCalledWith(params);
      });

      it('calls to maybeAddMetadata with correct params', async () => {
        expect.assertions(1);
        await action_helpers.acceptTransferAction(params);
        expect(maybeAddMetadata).toBeCalledWith(params);
      });

      it('evaluates the time dependence of the params', async () => {
        expect.assertions(1);
        await action_helpers.acceptTransferAction(params);
        expect(evaluateTimeDependence).toBeCalledWith(params);
      });

      it('calls CPFService to transfer the conversation', async () => {
        expect.assertions(1);
        await action_helpers.acceptTransferAction(params);
        expect(mockCPFService_Transfer).toBeCalledTimes(1);
      });

      it('calls CPFService to transfer the conversation with the correct params', async () => {
        expect.assertions(1);
        await action_helpers.acceptTransferAction(params);
        expect(mockCPFService_Transfer).toBeCalledWith(params);
      });
    });

    describe("when there are errors", () => {
      beforeEach(() => {
        mockLoggerError.mockClear();
        mockCPFService_AddMultipleMsgs.mockClear();
      })
      describe("when messages cannot be added to conversation", () => {
        beforeEach(() => {
          mockCPFService_AddMultipleMsgs.mockImplementationOnce(
            () => {return Promise.reject("fail");}
          )
        });

        it("does not call to CPFtransfer", async () => {
          expect.assertions(1);
          await action_helpers.acceptTransferAction(params);
          expect(mockCPFService_Transfer).not.toHaveBeenCalled()
        });

        it("adds error message to the agent", async () => {
          expect.assertions(1);
          await action_helpers.acceptTransferAction(params);
          expect(mockCPFService_AddMultipleMsgs).toHaveBeenCalledWith(params, params.messages.error);
        });

        it("does not set context of the agent", async () => {
          expect.assertions(1);
          await action_helpers.acceptTransferAction(params);
          expect(mSetContext).not.toHaveBeenCalled();
        });
      });

      describe("when projects cannot be added to conversation", () => {
        const params = {
          project_list: ["project_tag_1"],
          messages: {
            accept: [
              "OK, we will transfer.",
              "Someone will be talking to you soon."
            ],
            reject: ["We cannot transfer right now."],
            error: ["Something went wrong. Please try again"]
          }
        }

        beforeEach(() => {
          mockCPFService_AddMultipleMsgs.mockClear();
          maybeAddProjects.mockReset();
          maybeAddProjects.mockImplementationOnce(
            () => {return Promise.rejecy("fail");}
          )
        });

        it("does not call to CPFtransfer", async () => {
          expect.assertions(1);
          await action_helpers.acceptTransferAction(params);
          expect(mockCPFService_Transfer).not.toHaveBeenCalled()
        });

        it("adds error message to the agent", async () => {
          expect.assertions(1);
          await action_helpers.acceptTransferAction(params);
          expect(mockCPFService_AddMultipleMsgs).toHaveBeenCalledWith(params, params.messages.error);
        });

        it("does not set context of the agent", async () => {
          expect.assertions(1);
          await action_helpers.acceptTransferAction(params);
          expect(mSetContext).not.toHaveBeenCalled();
        });
      });

      describe("when taggs cannot be added to conversation", () => {
        const params = {
          project_list: ["project_tag_1"],
          messages: {
            accept: [
              "OK, we will transfer.",
              "Someone will be talking to you soon."
            ],
            reject: ["We cannot transfer right now."],
            error: ["Something went wrong. Please try again"]
          }
        }
        beforeEach(() => {
          mockCPFService_AddMultipleMsgs.mockClear();
          maybeAddTags.mockReset();
          maybeAddTags.mockImplementationOnce(
            () => {return Promise.reject("fail");}
          )
        });
        it("does not call to CPFtransfer", async () => {
          expect.assertions(1);
          await action_helpers.acceptTransferAction(params);
          expect(mockCPFService_Transfer).not.toHaveBeenCalled()
        });
        it("adds error message to the agent", async () => {
          expect.assertions(1);
          await action_helpers.acceptTransferAction(params);
          expect(mockCPFService_AddMultipleMsgs).toHaveBeenCalledWith(params, params.messages.error);
        });
        it("does not set context of the agent", async () => {
          expect.assertions(1);
          await action_helpers.acceptTransferAction(params);
          expect(mSetContext).not.toHaveBeenCalled();
        });
      });

      describe("when metadata cannot be added to conversation", () => {
        const params = {
          project_list: ["project_tag_1"],
          messages: {
            accept: [
              "OK, we will transfer.",
              "Someone will be talking to you soon."
            ],
            reject: ["We cannot transfer right now."],
            error: ["Something went wrong. Please try again"]
          }
        }
        beforeEach(() => {
          mockCPFService_AddMultipleMsgs.mockClear();
          maybeAddMetadata.mockReset();
          maybeAddMetadata.mockImplementationOnce(
            () => {return Promise.reject("fail");}
          )
        });
        it("does not call to CPFtransfer", async () => {
          expect.assertions(1);
          await action_helpers.acceptTransferAction(params);
          expect(mockCPFService_Transfer).not.toHaveBeenCalled()
        });
        it("adds error message to the agent", async () => {
          expect.assertions(1);
          await action_helpers.acceptTransferAction(params);
          expect(mockCPFService_AddMultipleMsgs).toHaveBeenCalledWith(params, params.messages.error);
        });
        it("does not set context of the agent", async () => {
          expect.assertions(1);
          await action_helpers.acceptTransferAction(params);
          expect(mSetContext).not.toHaveBeenCalled();
        });
        it("logs the error message", async () => {
          expect.assertions(1);
          await action_helpers.acceptTransferAction(params);
          expect(mockLoggerError).toHaveBeenCalledWith("Error in preparation of transfer action:", "fail");
        });
      });

      describe("when call to CPF transfer fails", () => {
        const params = {
          project_list: ["project_tag_1"],
          messages: {
            accept: [
              "OK, we will transfer.",
              "Someone will be talking to you soon."
            ],
            reject: ["We cannot transfer right now."],
            error: ["Something went wrong. Please try again"]
          }
        }
        beforeEach(() => {
          mockCPFService_AddMultipleMsgs.mockClear();
          mockCPFService_AddMultipleMsgs.mockImplementationOnce();
          mockCPFService_Transfer.mockImplementationOnce(
            () => {return Promise.reject("fail");}
          )
        });
        it("calls to CPFtransfer", async () => {
          expect.assertions(1);
          await action_helpers.acceptTransferAction(params);
          expect(mockCPFService_Transfer).toHaveBeenCalled()
        });
        it("adds error message to the agent", async () => {
          expect.assertions(1);
          await action_helpers.acceptTransferAction(params);
          expect(mockCPFService_AddMultipleMsgs).toHaveBeenCalledWith(params, params.messages.error);
        });
        it("does not set context of the agent", async () => {
          expect.assertions(1);
          await action_helpers.acceptTransferAction(params);
          expect(mSetContext).not.toHaveBeenCalled();
        });
        it("logs the error message", async () => {
          expect.assertions(1);
          await action_helpers.acceptTransferAction(params);
          expect(mockLoggerError).toHaveBeenCalledWith("Error during transfer call to CPF:", "fail");
        });
      });
    });
  });
});

