const uuid = require("uuid");
const { advanceTo, clear } = require('jest-date-mock');
const { applyLogic, hasAllowedDate } = require('../../../src/helpers/integrations/paymentCode');
const constants = require('../../../src/constants');
const helpers = require('../../../src/actions/cpf/helpers');
const actions = require('../../../src/actions/cpf/base');
const df_service = require("./../../../src/services/dialogflow");
const service_helper = require("./../../../src/services/helper");
const context_helper = require("./../../../src/helpers/contexts");
let { CPFService } = require('../../../src/services/cpf_service');
let { AdaptorexService } = require("../../../src/services/adaptorex_service");

jest.mock("uuid");

const mockSetContext = jest.spyOn(df_service, "setContext").mockImplementation();

const mockCPFService_AddMetadata = jest.fn();
CPFService.addMetadata = mockCPFService_AddMetadata;

const mockAddMessage = jest.fn();
AdaptorexService.addMessage = mockAddMessage;

const mAddTags = jest.spyOn(helpers, "addTags").mockImplementation();
const mTransfer = jest.spyOn(actions, "transferConversation").mockImplementation();

const mockLoggerError = jest.fn();
const mockLoggerInfo = jest.fn();

const mSendRequest = jest.spyOn(service_helper, "sendRequest").mockImplementation();

jest.mock("./../../../src/helpers/logger", () => {
  return {
    getLogger: jest.fn(() => ({
      info: jest.fn((...args) => mockLoggerInfo(...args)),
      error: jest.fn((...args) => mockLoggerError(...args)),
    })),
  };
});

jest.useFakeTimers();

describe("applyPaymentCodeLogic", () => {
    beforeEach(() => {
      mockSetContext.mockClear();
      mockAddMessage.mockClear();
      mockLoggerError.mockClear();
      mTransfer.mockClear();
      mAddTags.mockClear();
      mSendRequest.mockClear();
      CPFService.addMetadata.mockClear();
      clear();
    });
    const params = {
      url: "http://test.com",
      authToken: "abcabc",
      organization: "org1",
      conversation_id: 25,
      provider: "letstalk_agent",
      topic: "topicA",
      session: "s1",
      env: "production",
      availability: {
        timezone: "America/Santiago"
      },
      contexts: [],
      integration: {
        name: "payment_code",
        organization: "normaliza",
        customParams: ["rut"],
        allowedStatuses: ["Creada", "Visualizada"],
        excludedCampaigns: ["CUOTA_DIA", "EXCLUDED"],
        successMessage: "Su código de pago es el **param.ordenCodigo** por un monto de **$param.ordenTotal** el cual puede cancelar haciendo [click aqui](param.permalink). Vigente hasta **param.fechaLimite**. \n\n ¿te puedo ayudar con algo más?",
        tag_list: ["tagTest"],
        noDebtMessage: ["All payments up do date. What else can I help you with?"],
        url_publish_codes_whatsapp: "https://www.url.com",
      }
    };
    const permalink = "permalink";
    const ordenTotal = 1000;
    const ordenCodigo = 1234;
    const fechaLimite = "9999-01-01";
    const paymentCode = {
      permalink: permalink,
      ordenTotal: ordenTotal,
      ordenCodigo: ordenCodigo,
      fechaLimite: fechaLimite,
    };
    describe("when there is a payment code", () => {
      describe("when campaign is excluded campaign", () => {
        beforeEach(()=>{
          paymentCode.campanna = "EXCLUDED",
          paymentCode.ordenEstadoNombre = "Creada";
        });
        const data = [paymentCode];
          it("returns false", async () => {
            const result = await applyLogic(params, data);
            expect(result).toBeFalsy();
          });
          it("does not add a message", async () => {
            await applyLogic(params, data);
            expect(mockAddMessage).not.toHaveBeenCalled();
          });
          it("does not set the bot's context", async () => {
            await applyLogic(params, data);
            expect(mockSetContext).not.toHaveBeenCalled();
          });
          it("transfers the conversation", async () => {
            await applyLogic(params, data);
            expect(mTransfer).toHaveBeenCalledWith(params);
          });
      });

      describe("when campaign is CUOTA_DIA", () => {
        beforeEach(()=>{
          paymentCode.campanna = "CUOTA_DIA",
          paymentCode.ordenEstadoNombre = "Creada";
        });
        const data = [paymentCode];
          it("adds no debt message", async () => {
            await applyLogic(params, data);
            expect(mockAddMessage).toHaveBeenCalledWith(
              params,
              ["All payments up do date. What else can I help you with?"]);
          });
          it("sets the bot's context", async () => {
            await applyLogic(params, data);
            expect(mockSetContext).toHaveBeenCalledWith(params, constants.contextNewTopic);
          });
          it("does not transfer the conversation", async () => {
            await applyLogic(params, data);
            expect(mTransfer).not.toHaveBeenCalledWith(params);
          });
      });

      describe("when campaign is allowed campaign", () => {
        describe("when payment status is creada", () => {
          beforeEach(()=>{
            paymentCode.campanna = "Campaign1",
            paymentCode.ordenEstadoNombre = "Creada";
          });
          const data = [paymentCode];

          describe("when provider is undefined", () => {
            it("adds expected message to the conversation", async () => {
              expect.assertions(1);
              const expectedMessage = "Su código de pago es el **1234** por un monto de **$1000** el cual puede cancelar haciendo [click aqui](permalink). Vigente hasta **9999-01-01**. \n\n ¿te puedo ayudar con algo más?";
              await applyLogic(params, data);
              jest.runAllTimers();
              expect(mockAddMessage).toBeCalledWith(params, expectedMessage);
            });

            it("adds tags", async () => {
              const expectedParams = {...params, ...{tag_list: params.integration.tag_list} };
              await applyLogic(params, data);
              expect(mAddTags).toBeCalledWith(expectedParams);
            });
            it("adds the paymentcode to the bots context", async () => {
              const expectedContext = {
                name: "paymentcodes",
                lifespan: 50,
                parameters: {
                  paymentcodes: "1234",
                }
              };
              await applyLogic(params, data);
              expect(mockSetContext).toBeCalledWith(params, expectedContext);
            });

            it("adds the correct metadata to the conversation", async () => {
              const metadata = {
                paymentcodes: "1234",
              }
              await applyLogic(params, data);
              expect(CPFService.addMetadata).toBeCalledWith(params, metadata);
            });
          });

          describe("when provider is twilio", () => {
            const paramsTwilio = {...params, ...{provider: constants.providers.twilio}};

            it("adds expected message to the conversation", async () => {
              const expectedMessage = "Su código de pago es el **1234** por un monto de **$1000** el cual puede cancelar haciendo [click aqui](permalink). Vigente hasta **9999-01-01**. \n\n ¿te puedo ayudar con algo más?";
              await applyLogic(paramsTwilio, data);
              expect(mockAddMessage).toHaveBeenCalledWith(paramsTwilio, expectedMessage);
            });

            it("sets the bot's context correctly", async () => {
              await applyLogic(paramsTwilio, data);
              expect(mockSetContext).toHaveBeenNthCalledWith(1, paramsTwilio, constants.contextNewTopic);
            });

            it("does not add the tags", async () => {
              await applyLogic(paramsTwilio, data);
              expect(mAddTags).not.toHaveBeenCalled();
            });
            it("adds the paymentcode to the bot's context", async () => {
              const expectedContext = {
                name: "paymentcodes",
                lifespan: 50,
                parameters: {
                  paymentcodes: "1234",
                }
              };
              await applyLogic(paramsTwilio, data);
              expect(mockSetContext).toHaveBeenNthCalledWith(2, paramsTwilio, expectedContext);
            });

            it("does not add metadata to the conversation", async () => {
              await applyLogic(paramsTwilio, data);
              expect(CPFService.addMetadata).not.toHaveBeenCalled();
            });

            it("publishes whatsapp code using integrator", async () => {
              const date = new Date("June 17, 2020 15:01:00-04:00");
              advanceTo(date);
              jest.spyOn(uuid, "v4").mockImplementationOnce(() => 'uuid-v4');
              const expectedOptions = {
                url: "https://www.url.com",
                payload: {
                  body: {
                    payload: {
                      topic: "topicA",
                      provider: constants.providers.twilio,
                      reference: "s1",
                      event_time: date.toISOString(),
                      event_id: "uuid-v4",
                      metadata: {
                        payment_code: "1234",
                      },
                    },
                  },
                  method: "POST",
                }
              }
              await applyLogic(paramsTwilio, data);
              expect(mSendRequest).toHaveBeenCalledWith(expectedOptions);
            })
          });
        });
        describe("when payment status is visualizada", () => {
          beforeEach(()=>{
            paymentCode.campanna = "Campaign1",
            paymentCode.ordenEstadoNombre = "Visualizada";
          });
          const data = [paymentCode];
          it("adds expected message to the conversation", async () => {
            const expectedMessage = "Su código de pago es el **1234** por un monto de **$1000** el cual puede cancelar haciendo [click aqui](permalink). Vigente hasta **9999-01-01**. \n\n ¿te puedo ayudar con algo más?";
            await applyLogic(params, data);
            expect(mockAddMessage).toBeCalledWith(params, expectedMessage);
          });
          it("sets the bot's context correctly", async () => {
            await applyLogic(params, data);
            expect(mockSetContext).toHaveBeenNthCalledWith(1  , params, constants.contextNewTopic);
          });
        });
        describe("when payment status is other", () => {
          beforeEach(()=>{
            paymentCode.campanna = "Campaign1",
            paymentCode.ordenEstadoNombre = "otro";
          });
          const data = [paymentCode];
          it("returns false", async () => {
            const result = await applyLogic(params, data);
            expect(result).toBeFalsy();
          });
          it("does not add a message", async () => {
            await applyLogic(params, data);
            expect(mockAddMessage).not.toHaveBeenCalled();
          });
          it("does not set the bot's context", async () => {
            await applyLogic(params, data);
            expect(mockSetContext).not.toHaveBeenCalled();
          });
          it("transfers the conversation", async () => {
            await applyLogic(params, data);
            expect(mTransfer).toHaveBeenCalledWith(params);
          });
        });
      });
    });

    describe("when there is no payment code", () => {
      const data = []
      it("returns false", async () => {
        const result = await applyLogic(params, data);
        expect(result).toBeFalsy();
      });
      it("does not add a message", async () => {
        await applyLogic(params, data);
        expect(mockAddMessage).not.toHaveBeenCalled();
      });
      it("does not set the bot's context", async () => {
        await applyLogic(params, data);
        expect(mockAddMessage).not.toHaveBeenCalled();
      });
      it("transfers the conversation", async () => {
        await applyLogic(params, data);
        expect(mTransfer).toHaveBeenCalledWith(params);
      });
    });

    describe("when there are multiple valid payment codes", () => {
      beforeEach(()=>{
        paymentCode.campanna = "Campaign1",
        paymentCode.ordenEstadoNombre = "Creada";
      });
      const data = [paymentCode, paymentCode];
      it("returns false", async () => {
        const result = await applyLogic(params, data);
        expect(result).toBeFalsy();
      });
      it("does not add a message", async () => {
        await applyLogic(params, data);
        expect(mockAddMessage).not.toHaveBeenCalled();
      });
      it("does not set the bot's context", async () => {
        await applyLogic(params, data);
        expect(mockSetContext).not.toHaveBeenCalled();
      });
      it("transfers the conversation", async () => {
        await applyLogic(params, data);
        expect(mTransfer).toHaveBeenCalledWith(params);
      });
    });

    describe("when user requests a second code", () => {
      beforeEach(() => {
        paymentCode.campanna = "Campaign1",
        paymentCode.ordenEstadoNombre = "Creada";
        params.contexts = [
          {
            name: "paymentcodes",
            lifespan: 50,
            parameters: {
              paymentcodes: "4321",
            }
          }
        ]
      }
    );
    const data = [paymentCode];
    it("adds correct metadata to the conversation", async () => {
        const expectedMetadata = {
          paymentcodes: "4321,1234",
        }
        await applyLogic(params, data);
        expect(CPFService.addMetadata).toBeCalledWith(params, expectedMetadata);
    });
    it("correct context was set for bot", async () => {
      await applyLogic(params, data);
      expect(mockSetContext).toHaveBeenCalledWith(params, {
        name: "paymentcodes",
        lifespan: 50,
        parameters: {
          paymentcodes: "4321,1234",
        }
      });
    })
  });

  describe("failure cases", () => {
    const err = new Error("fail");
    beforeEach(()=>{
      paymentCode.campanna = "Campaign1",
      paymentCode.ordenEstadoNombre = "Creada";
    });
    const data = [paymentCode];

    describe("when add message to Adaptorex fails", () => {
      beforeEach(() => {
        mockAddMessage.mockImplementationOnce(() => {
          return Promise.reject(err);
        })
      });

      it("throws correct error", async () => {
        expect.assertions(1);
        await expect(applyLogic(params, data))
        .rejects
        .toThrow("Could not send payment code message to end user");
      });

      it("logs the error", async () => {
        expect.assertions(1);
        try {
          await applyLogic(params, data);
        }
        catch (error) {
          expect(mockLoggerError).toHaveBeenNthCalledWith(
            1,
            "Could not send payment code message to end user",
            { error: err },
          )
        }
      });

      it("does not set the context of the bot", async () => {
        expect.assertions(1);
        try {
          await applyLogic(params, data);
        } catch (error) {}
        expect(mockSetContext).not.toHaveBeenCalled();
      });

      it("does not tag the conversation", async () => {
        expect.assertions(1);
        try {
          await applyLogic(params, data);
        } catch (error) {}
        expect(mAddTags).not.toHaveBeenCalled();
      });

      it("does not add metadata to the CPF conversation", async () => {
        expect.assertions(1);
        try {
          await applyLogic(params, data);
        } catch (error) {}
        expect(CPFService.addMetadata).not.toHaveBeenCalled();
      });
    });

    describe("when context can not be set", () => {
      beforeEach(() => {
        mockSetContext.mockImplementationOnce(() => {
          return Promise.reject(err);
        })
      });

      it("logs the error", async () => {
        expect.assertions(1);
        await applyLogic(params, data);
        expect(mockLoggerError).toHaveBeenNthCalledWith(
          1,
          "Could not fully complete payment code logic",
          { rejects: [
            {
              status: "rejected",
              reason: err,
            }
          ] },
        )
      });
    });
  })
});

describe("hasAllowedDate", () => {
  const paymentCode = {
    fechaLimite: "2020-06-18"
  };

  beforeEach(() => {
    clear();
  });

  describe("when fechaLimite lies in future", () => {
    beforeEach(() => {
      advanceTo(new Date('June 17, 2020 23:59:59-04:00'));
    });

    const params = {
      availability: {
        timezone: "America/Santiago"
      }
    };

    it("returns true", () => {
      expect(hasAllowedDate(paymentCode, params)).toBeTruthy();
    });
  });

  describe("when fechaLimite is today", () => {
    beforeEach(() => {
      advanceTo(new Date('June 18, 2020 15:00:00-04:00'));
    });

    const params = {
      availability: {
        timezone: "America/Santiago"
      }
    };

    it("returns true", () => {
      expect(hasAllowedDate(paymentCode, params)).toBeTruthy();
    });
  });

  describe("when fechaLimite lies in past", () => {
    beforeEach(() => {
      advanceTo(new Date('June 19, 2020 00:00:01-04:00'));
    });

    const params = {
      availability: {
        timezone: "America/Santiago"
      }
    };

    it("returns false", () => {
      expect(hasAllowedDate(paymentCode, params)).toBeFalsy();
    });
  });
})