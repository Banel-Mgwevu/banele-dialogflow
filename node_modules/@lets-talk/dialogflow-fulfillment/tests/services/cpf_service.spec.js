let cpf_service = require('../../src/services/cpf_service');

const mockGot = jest.fn();
jest.mock('got', () => jest.fn((...args) => mockGot(...args)));

const mockLoggerError = jest.fn();
const mockLoggerInfo = jest.fn();

jest.mock("./../../src/helpers/logger", () => {
  return {
    getLogger: jest.fn(() => ({
      info: jest.fn((...args) => mockLoggerInfo(...args)),
      error: jest.fn((...args) => mockLoggerError(...args)),
    })),
  };
});


describe('A CPFService', () => {
  beforeEach(() => {
    mockLoggerInfo.mockClear();
    mockLoggerError.mockClear();
  })

  describe('CPFService closing action', () => {
    const expectedUrl = "https://we.letsta.lk/api/v1/conversations/1";
    const expectedPayload = {
      method: "PUT",
      headers: {
        Authorization: "Basic token1"
      },
      body: {
        status: "Closed"
      },
      json: true
    };
    const settings = {
      organization: "we",
      conversation_id: 1,
      token: 'token1',
      environment: 'production',
      };

    describe('A successful closing action', () => {

      beforeEach(async () => {
        mockGot.mockClear();
        mockGot.mockImplementationOnce(
          () => new Promise((resolve) => resolve({body: "ok"}))
        );

        await cpf_service.CPFService.close(settings);
      });

      it('calls API once', () => {
        expect(mockGot).toHaveBeenCalledTimes(1);
      });

      it('calls the correct url', () => {
        expect(mockGot.mock.calls[0][0]).toEqual(expectedUrl);
      });

      it('calls with the correct payload', () => {
        expect(mockGot.mock.calls[0][1]).toEqual(expectedPayload);
      })
    });

    describe('A failing closing action', () => {
      const err = new Error("fail");
      beforeEach(() => {
        mockGot.mockClear();
        mockGot.mockImplementationOnce(
          () => Promise.reject(err)
        );
      });

      it('calls the API once', async () => {
        expect.assertions(1);
        try{
          await cpf_service.CPFService.close(settings);
        } catch (error) {
          expect(mockGot).toHaveBeenCalledTimes(1);
        }
      });

      it('logs error to console', async () => {
        expect.assertions(1);
        try{
          await cpf_service.CPFService.close(settings);
        } catch (error) {
          expect(mockLoggerError).toHaveBeenNthCalledWith(
            1, "Error when calling API.", {
              error: err,
              options: {
                url: expectedUrl,
                payload: expectedPayload,
              }
            });
        }
      });
    });
  });

  describe('CPFService addProjects action', () => {
    const settings = {
      organization: "we",
      conversation_id: 1,
      token: 'token1',
      environment: 'production',
      project_list: ["SPR-PERS"],
    };
    const expectedUrl = "https://we.letsta.lk/api/v1/tags";
    const expectedPayload = {
      method: "POST",
      headers: {
        Authorization: "Basic token1"
      },
      body: {
        conversation_id: 1,
        project_list: ["SPR-PERS"],
      },
      json: true
    };
    describe('A successful add projects action', () => {

      beforeEach( async () => {
        mockGot.mockClear();
        mockGot.mockImplementationOnce(
          () => new Promise((resolve) => resolve({body: "ok"}))
        );

        await cpf_service.CPFService.addProjects(settings);
      })

      it('calls API once', () => {
        expect(mockGot).toHaveBeenCalledTimes(1);
      });

      it('calls the correct url', () => {
        expect(mockGot.mock.calls[0][0]).toEqual(expectedUrl);
      });

      it('calls with the correct payload', () => {
        expect(mockGot.mock.calls[0][1]).toEqual(expectedPayload);
      })
    });

    describe('A failing add projects action', () => {
      const err = new Error("fail");
      beforeEach(() => {
        mockGot.mockClear();
        mockGot.mockImplementationOnce(
          () => Promise.reject(err)
        );
      });

      it('calls the API once', async () => {
        expect.assertions(1);
        try{
          await cpf_service.CPFService.addProjects(settings);
        } catch (error) {
          expect(mockGot).toHaveBeenCalledTimes(1);
        }
      });

      it('logs error to console', async () => {
        expect.assertions(1);
        try{
          await cpf_service.CPFService.addProjects(settings);
        } catch (error) {
          expect(mockLoggerError).toHaveBeenNthCalledWith(
            1, "Error when calling API.", {
              error: err,
              options: {
                url: expectedUrl,
                payload: expectedPayload,
              }
            });
        }
      });
    });
  });

  describe('CPFService addTags action', () => {
    const settings = {
      organization: "we",
      conversation_id: 1,
      token: 'token1',
      environment: 'production',
      tag_list: ["CC-Pago"],
    };
    const expectedUrl = "https://we.letsta.lk/api/v1/tags";
    const expectedPayload = {
      method: "POST",
      headers: {
        Authorization: "Basic token1"
      },
      body: {
        conversation_id: 1,
        tag_list: ["CC-Pago"],
      },
      json: true
    };
    describe('A successful add tags action', () => {

      beforeEach(async () => {
        mockGot.mockClear();
        mockGot.mockImplementationOnce(
          () => new Promise((resolve) => resolve({body: "ok"}))
        );

        await cpf_service.CPFService.addTags(settings);
      })

      it('calls API once', () => {
        expect(mockGot).toHaveBeenCalledTimes(1);
      });

      it('calls the correct url', () => {
        expect(mockGot.mock.calls[0][0]).toEqual(expectedUrl);
      });

      it('calls with the correct payload', () => {
        expect(mockGot.mock.calls[0][1]).toEqual(expectedPayload);
      })
    });

    describe('A failing add tags action', () => {
      const err = new Error("fail");
      beforeEach(() => {
        mockGot.mockClear();
        mockGot.mockImplementationOnce(
          () => Promise.reject(err)
        );
      });

      it('calls the API once', async () => {
        expect.assertions(1);
        try{
          await cpf_service.CPFService.addTags(settings);
        } catch (error) {
          expect(mockGot).toHaveBeenCalledTimes(1);
        }
      });

      it('logs error to console', async () => {
        expect.assertions(1);
        try{
          await cpf_service.CPFService.addTags(settings);
        } catch (error) {
          expect(mockLoggerError).toHaveBeenNthCalledWith(
            1, "Error when calling API.", {
              error: err,
              options: {
                url: expectedUrl,
                payload: expectedPayload,
              }
            })
        }
      });
    });
  });

  describe('CPFService Transfer action', () => {
    const settings = {
      organization: "we",
      conversation_id: 1,
      token: 'token1',
      environment: 'production',
      group_id: 123
    };
    const expectedPayload = {
      method: "POST",
      headers: {
        Authorization: "Basic token1"
      },
      body: {
        transfer: true,
        uniq: true
      },
      json: true
    };
    const expectedUrl = "https://we.letsta.lk/api/v1/conversations/1/conversation_groups?group_id=123";
    describe('A successful transfer action', () => {

      beforeEach(async () => {
        mockGot.mockClear();
        mockGot.mockImplementationOnce(
          () => new Promise((resolve) => resolve({body: "ok"}))
        );

        await cpf_service.CPFService.transfer(settings);
      })

      it('calls API once', () => {
        expect(mockGot).toHaveBeenCalledTimes(1);
      });

      it('calls the correct url', () => {
        expect(mockGot.mock.calls[0][0]).toEqual(expectedUrl);
      });

      it('calls with the correct payload', () => {
        expect(mockGot.mock.calls[0][1]).toEqual(expectedPayload);
      })
    });

    describe('A failing transfer action', () => {
      const err = new Error("fail");
      beforeEach(() => {
        mockGot.mockClear();
        mockGot.mockImplementationOnce(
          () => Promise.reject(err)
        );
      });

      it('calls the API once', async () => {
        expect.assertions(1);
        try{
          await cpf_service.CPFService.transfer(settings);
        } catch (error) {
          expect(mockGot).toHaveBeenCalledTimes(1);
        }
      });

      it('logs error to console', async () => {
        expect.assertions(1);
        try{
          await cpf_service.CPFService.transfer(settings);
        } catch (error) {
          expect(mockLoggerError).toHaveBeenNthCalledWith(
            1, "Error when calling API.", {
              error: err,
              options: {
                url: expectedUrl,
                payload: expectedPayload,
              }
            })
        }
      });
    });
  });

  describe('CPFService addMetadata action', () => {
    const settings = {
      organization: "we",
      conversation_id: 1,
      token: 'token1',
      environment: 'production',
    };
    const metadata = {md1: "md-val1"};
    const expectedUrl = "https://we.letsta.lk/api/v1/conversations/1/metadata";
    const expectedPayload = {
      method: "POST",
      headers: {
        Authorization: "Basic token1"
      },
      body: {
        transfer: true,
      },
      body: {
        md1: "md-val1"
      },
      json: true
    };

    describe('A successful addMetadata action', () => {

      beforeEach(async () => {
        mockGot.mockClear();
        mockGot.mockImplementationOnce(
          () => new Promise((resolve) => resolve({body: "ok"}))
        );
        await cpf_service.CPFService.addMetadata(settings, metadata);
      })

      it('calls API once', () => {
        expect(mockGot).toHaveBeenCalledTimes(1);
      });

      it('calls the correct url', () => {
        expect(mockGot.mock.calls[0][0]).toEqual(expectedUrl);
      });

      it('calls with the correct payload', () => {
        expect(mockGot.mock.calls[0][1]).toEqual(expectedPayload);
      })
    });

    describe('A failing addMetadata action', () => {
      const err = new Error("fail");
      beforeEach(() => {
        mockGot.mockClear();
        mockGot.mockImplementationOnce(
          () => Promise.reject(err)
        );
      });

      it('calls the API once', async () => {
        expect.assertions(1);
        try{
          await cpf_service.CPFService.addMetadata(settings, metadata);
        } catch (error) {
          expect(mockGot).toHaveBeenCalledTimes(1);
        }
      });

      it('logs error to console', async () => {
        expect.assertions(1);
        try{
          await cpf_service.CPFService.addMetadata(settings, metadata);
        } catch (error) {
          expect(mockLoggerError).toHaveBeenNthCalledWith(
            1, "Error when calling API.", {
              error: err,
              options: {
                url: expectedUrl,
                payload: expectedPayload,
              }
            })
        }
      });
    });

    describe('CPFService addMultipleMessages', () => {
      const settings = {
        organization: "lt",
        conversation_id: 1,
        messages: {
          accept: ["msg1", "msg2"],
        }
      };
      const messages = ["msg1", "msg2"];
      const expectedUrl = "https://lt.staging.letsta.lk/api/v1/conversations/1/messages";

      beforeEach(async () => {
        mockGot.mockClear();
        mockGot.mockImplementation(
          () => new Promise((resolve) => resolve({body: "ok"}))
        );
        await cpf_service.CPFService.addMultipleMessages(settings, messages);
      })

      it('calls the API twice', () => {
        expect(mockGot).toHaveBeenCalledTimes(2);
      });

      it('calls the correct url', () => {
        expect(mockGot.mock.calls[0][0]).toEqual(expectedUrl);
      });

      it('sends the expected first message', () => {
        expect(mockGot.mock.calls[0][1].body.content).toEqual("msg1");
      });

      it('sends the expected second message', () => {
        expect(mockGot.mock.calls[1][1].body.content).toEqual("msg2");
      });

    });
  });
});