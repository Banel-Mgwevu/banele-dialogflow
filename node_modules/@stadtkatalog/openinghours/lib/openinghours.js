"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __timezone, __holidays, __hours, __specialDays, _isInvalidDate;
Object.defineProperty(exports, "__esModule", { value: true });
const luxon_1 = require("luxon");
const types_1 = require("./types");
const helpers_1 = require("./helpers");
const DEFAULT_LOCALE = Intl.DateTimeFormat().resolvedOptions().locale;
/**
 * Stores opening hours and provides methods to work with them.
 * @see https://docs.stadtkatalog.org/
 */
class OpeningHours {
    /**
     * Creates a new instance with the given opening hours in the specified time zone.
     * @param hours contains the opening hours for each day. If a weekday key is not defined, the opening
     *        hours on this particular day are unknown. If a weekday key references an empty array `[]`,
     *        the entity is closed on this day. In all other cases a weekday key references an array
     *        with multiple time frames in the format `["hh:mm", "hh:mm", ...]`.
     *        Special days must be in the form `YYYY-MM-DD`
     * @param timezone the time zone of the entity
     * @param holidays=[] set of holidays in the format `YYYY-MM-DD`
     */
    constructor(hours, timezone, holidays = []) {
        /** @ignore */
        __timezone.set(this, void 0);
        /** @ignore */
        __holidays.set(this, void 0);
        /** @ignore */
        __hours.set(this, {});
        /** @ignore */
        __specialDays.set(this, {});
        /** @ignore */
        _isInvalidDate.set(this, (date) => {
            const dt = luxon_1.DateTime.fromFormat(date, "yyyy-MM-dd");
            return !dt.isValid;
        }
        /**
         * Creates a new instance with the given opening hours in the specified time zone.
         * @param hours contains the opening hours for each day. If a weekday key is not defined, the opening
         *        hours on this particular day are unknown. If a weekday key references an empty array `[]`,
         *        the entity is closed on this day. In all other cases a weekday key references an array
         *        with multiple time frames in the format `["hh:mm", "hh:mm", ...]`.
         *        Special days must be in the form `YYYY-MM-DD`
         * @param timezone the time zone of the entity
         * @param holidays=[] set of holidays in the format `YYYY-MM-DD`
         */
        );
        if (holidays === null || holidays === void 0 ? void 0 : holidays.some(__classPrivateFieldGet(this, _isInvalidDate))) {
            throw Error("Invalid date keys in holidays or specialDays.");
        }
        const validKeys = (helpers_1.WEEKDAY_KEYS.concat(["hol"]));
        for (const key of Object.keys(hours)) {
            if (validKeys.includes(key)) {
                __classPrivateFieldGet(this, __hours)[key] = hours[key];
            }
            else {
                if (__classPrivateFieldGet(this, _isInvalidDate).call(this, key)) {
                    throw Error(`Invalid key '${key}' in hours object.`);
                }
                else {
                    __classPrivateFieldGet(this, __specialDays)[key] = hours[key];
                }
            }
        }
        __classPrivateFieldSet(this, __timezone, timezone);
        __classPrivateFieldSet(this, __holidays, holidays);
    }
    get timezone() {
        return __classPrivateFieldGet(this, __timezone);
    }
    get specialDays() {
        return __classPrivateFieldGet(this, __specialDays);
    }
    get holidays() {
        return __classPrivateFieldGet(this, __holidays);
    }
    get hours() {
        return __classPrivateFieldGet(this, __hours);
    }
    /**
     * Returns the shorthand name for the given weekday.
     * @param weekday 1 is Monday and 7 is Sunday
     * @returns {string} three letter weekday key
     */
    static weekdayToWeekdayKey(weekday) {
        switch (weekday) {
            case 1: return "mon";
            case 2: return "tue";
            case 3: return "wed";
            case 4: return "thu";
            case 5: return "fri";
            case 6: return "sat";
            case 7: return "sun";
        }
        throw new Error(`Invalid weekday index: ${weekday}`);
    }
    /**
     * Checks if the given date string is on a day with special opening hours.
     * @param dateStr the date in the format `YYYY-MM-DD`
     * @returns {boolean} `true` if holiday, `false` otherwise
     */
    isSpecialDay(dateStr) {
        return Object.keys(__classPrivateFieldGet(this, __specialDays)).indexOf(dateStr) >= 0;
    }
    /**
     * Checks if the given date string is on a holiday for the `IOpeningHours` instance.
     * @param dateStr the date in the format `YYYY-MM-DD`
     * @returns {boolean} `true` if holiday, `false` otherwise
     */
    isHoliday(dateStr) {
        return __classPrivateFieldGet(this, __holidays).indexOf(dateStr) >= 0;
    }
    /**
     * Checks if the preceding day is overlong and returns the weekday key of this overlong day.
     * An overlong day ends after 23:59 hours and continues into the following one,
     * e.g. if the business hours are on Friday from 10:00 - 04:00; or in a 24/7 shop from 00:00 - 24:00.
     * @param date JavaScript date
     * @returns {string} the preceding three-letter weekday key; or `null` if no overlong preceding day found
     */
    getOverlongPrecedingWeekdayKey(date) {
        const ldt = luxon_1.DateTime.fromJSDate(date).setZone(__classPrivateFieldGet(this, __timezone));
        const yesterday = ldt.plus({ days: -1 });
        const prevDayKey = this.isHoliday(yesterday.toFormat("yyyy-LL-dd"))
            ? "hol"
            : OpeningHours.weekdayToWeekdayKey(yesterday.weekday);
        return helpers_1._areOverlongTimeFrames(__classPrivateFieldGet(this, __hours)[prevDayKey]) ? prevDayKey : null;
    }
    /**
     * Returns true if the opening hours represented by the instance are unknown.
     */
    isUnknown() {
        return Object.keys(__classPrivateFieldGet(this, __hours)).length === 0 && Object.keys(__classPrivateFieldGet(this, __specialDays)).length === 0;
    }
    /**
     * Checks if the instance is open at the given date.
     * @param date {Object} JavaScript Date instance
     * @returns {boolean} true if the instance is open, false otherwise
     */
    isOpenAt(date) {
        const dayDT = luxon_1.DateTime.fromJSDate(date).setZone(__classPrivateFieldGet(this, __timezone));
        const precedingDayDT = dayDT.plus({ days: -1 });
        const dayFormatStr = dayDT.toFormat("yyyy-LL-dd");
        const precedingDayFormatStr = precedingDayDT.toFormat("yyyy-LL-dd");
        const timeFrames = this.isSpecialDay(dayFormatStr)
            // @ts-ignore slice(0) can never fail since its checked before
            ? __classPrivateFieldGet(this, __specialDays)[dayFormatStr].slice(0)
            : (__classPrivateFieldGet(this, __hours)[OpeningHours.weekdayToWeekdayKey(dayDT.weekday)] || []).slice(0);
        if (this.isSpecialDay(precedingDayFormatStr)) {
            const tfs = __classPrivateFieldGet(this, __specialDays)[precedingDayFormatStr];
            if (tfs) {
                timeFrames.push(...helpers_1._getAdditionalStartOfDayTimeFrames(tfs));
            }
        }
        else {
            // overflowing time frame detected, so add it to the set of time frames
            const precedingWeekdayKey = this.getOverlongPrecedingWeekdayKey(date);
            if (precedingWeekdayKey !== null) {
                const tfs = __classPrivateFieldGet(this, __hours)[precedingWeekdayKey];
                if (tfs) {
                    timeFrames.push(...helpers_1._getAdditionalStartOfDayTimeFrames(tfs));
                }
            }
        }
        // check if at least one time frame is overlapping and therefore the state must be "open"
        for (let i = 0; i < timeFrames.length; i += 2) {
            if (helpers_1._isInTimeFrame(dayDT, timeFrames[i], timeFrames[i + 1])) {
                return true;
            }
        }
        return false;
    }
    /**
     * Reduces the opening hours into an array of so-called `RangeTimeSpan` elements.
     * All elements in the array are in the most compact form possible. Consecutive matching time ranges will be merged
     * into a single elements with a day range as weekday string.
     *
     * @param formatOptions formatting options.
     * @see https://moment.github.io/luxon/docs/manual/intl.html
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat
     */
    reduce(formatOptions = {}) {
        const { hyphen, delimiter, locale, weekdayFormat, holidayPrefix, timeFrameFormat, timeFrameDelimiter, closedPlaceholder, specialDates, } = Object.assign({}, {
            hyphen: "\u202F\u2013\u202F",
            delimiter: ", ",
            locale: DEFAULT_LOCALE,
            weekdayFormat: types_1.WeekdayFormat.short,
            holidayPrefix: "Holidays",
            timeFrameFormat: "{start} to {end}",
            timeFrameDelimiter: " and ",
            closedPlaceholder: "Closed",
            specialDates: {
                format: "yyyy-MM-dd",
                from: undefined,
                to: undefined,
            }
        }, formatOptions);
        // type guard for potential undefined values in user-provided options
        if (holidayPrefix === undefined || timeFrameDelimiter === undefined || timeFrameFormat === undefined || closedPlaceholder === undefined) {
            throw new TypeError(`Invalid options object: format options cannot use undefined as value.`);
        }
        const reducedTimeRange = helpers_1._eliminateEqualRanges(__classPrivateFieldGet(this, __hours));
        const someMonday = luxon_1.DateTime
            .utc(2020, 5, 4)
            .setLocale(locale !== null && locale !== void 0 ? locale : DEFAULT_LOCALE);
        const shortWeekdays = [
            someMonday.toLocaleString({ weekday: weekdayFormat }),
            someMonday.plus({ days: 1 }).toLocaleString({ weekday: weekdayFormat }),
            someMonday.plus({ days: 2 }).toLocaleString({ weekday: weekdayFormat }),
            someMonday.plus({ days: 3 }).toLocaleString({ weekday: weekdayFormat }),
            someMonday.plus({ days: 4 }).toLocaleString({ weekday: weekdayFormat }),
            someMonday.plus({ days: 5 }).toLocaleString({ weekday: weekdayFormat }),
            someMonday.plus({ days: 6 }).toLocaleString({ weekday: weekdayFormat }),
        ];
        const rangeStrings = [];
        const rangeBag = helpers_1._createRangeBag(reducedTimeRange);
        Object.keys(rangeBag).sort().map(numStr => {
            const rangeNumber = Number(numStr);
            const bagOfDays = rangeBag[rangeNumber];
            if (helpers_1._canFoldIntoDayRange(bagOfDays) && bagOfDays.length > 1) {
                rangeStrings.push({
                    days: shortWeekdays[bagOfDays[0]] + hyphen + shortWeekdays[bagOfDays.slice(-1)[0]],
                    timeFrames: __classPrivateFieldGet(this, __hours)[helpers_1.WEEKDAY_KEYS[rangeNumber]] || []
                });
            }
            else {
                rangeStrings.push({
                    days: bagOfDays.map(function (dayIndex) {
                        return shortWeekdays[dayIndex];
                    }).join(delimiter),
                    timeFrames: __classPrivateFieldGet(this, __hours)[helpers_1.WEEKDAY_KEYS[rangeNumber]] || []
                });
            }
        });
        const reducedHours = rangeStrings.filter(foldedDayRange => foldedDayRange.timeFrames.length > 0)
            .map(foldedDayRange => {
            return {
                type: types_1.RangeType.weekday,
                range: foldedDayRange.days,
                timespan: helpers_1._formatTimeFrames(foldedDayRange.timeFrames, timeFrameFormat, timeFrameDelimiter, closedPlaceholder),
            };
        });
        if (Array.isArray(__classPrivateFieldGet(this, __hours).hol)) {
            reducedHours.push({
                type: types_1.RangeType.holiday,
                range: holidayPrefix,
                timespan: helpers_1._formatTimeFrames(__classPrivateFieldGet(this, __hours).hol, timeFrameFormat, timeFrameDelimiter, closedPlaceholder)
            });
        }
        const specialDays = Object.keys(__classPrivateFieldGet(this, __specialDays))
            .map(date => {
            return {
                dt: luxon_1.DateTime.fromFormat(date, "yyyy-MM-dd", {
                    zone: __classPrivateFieldGet(this, __timezone)
                }),
                timeFrames: __classPrivateFieldGet(this, __specialDays)[date]
            };
        })
            .filter(({ dt, timeFrames }) => {
            // this is just a guard; the constructor will never accept such inputs!
            if (!dt.isValid || timeFrames === undefined) {
                return false;
            }
            const from = luxon_1.DateTime
                .fromJSDate((specialDates === null || specialDates === void 0 ? void 0 : specialDates.from) || new Date())
                .startOf("day")
                .setZone(__classPrivateFieldGet(this, __timezone));
            if (dt.toSeconds() < from.toSeconds()) {
                return false;
            }
            if ((specialDates === null || specialDates === void 0 ? void 0 : specialDates.to) instanceof Date) {
                const to = luxon_1.DateTime
                    .fromJSDate(specialDates.to)
                    .endOf("day")
                    .setZone(__classPrivateFieldGet(this, __timezone));
                if (dt.toSeconds() > to.toSeconds()) {
                    return false;
                }
            }
            return true;
        })
            .filter((x) => {
            return x.timeFrames !== undefined;
        })
            .sort((a, b) => a.dt.toMillis() - b.dt.toMillis());
        reducedHours.push(...helpers_1._foldSpecialDayRanges(specialDays)
            .map(({ start, end }) => {
            var _a, _b, _c;
            const range = start.dt.diff(end.dt, "milliseconds").milliseconds === 0
                ? start.dt.toFormat(((_a = formatOptions.specialDates) === null || _a === void 0 ? void 0 : _a.format) || "yyyy-MM-dd")
                : start.dt.toFormat(((_b = formatOptions.specialDates) === null || _b === void 0 ? void 0 : _b.format) || "yyyy-MM-dd") +
                    hyphen + end.dt.toFormat(((_c = formatOptions.specialDates) === null || _c === void 0 ? void 0 : _c.format) || "yyyy-MM-dd");
            return {
                type: types_1.RangeType.special,
                range,
                timespan: helpers_1._formatTimeFrames(start.timeFrames, timeFrameFormat, timeFrameDelimiter, closedPlaceholder),
            };
        }));
        return reducedHours;
    }
    /**
     * Folds the opening hours into a human readable string.
     *
     * @param formatOptions formatting options.
     * @param separator the string to separate adjacent range timespans.
     * @see https://moment.github.io/luxon/docs/manual/intl.html
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat
     */
    fold(formatOptions = {}, separator = "\n") {
        return this
            .reduce(formatOptions)
            .map(rangeTimeSpan => `${rangeTimeSpan.range}: ${rangeTimeSpan.timespan}`)
            .join(separator);
    }
}
exports.OpeningHours = OpeningHours;
__timezone = new WeakMap(), __holidays = new WeakMap(), __hours = new WeakMap(), __specialDays = new WeakMap(), _isInvalidDate = new WeakMap();
//# sourceMappingURL=openinghours.js.map